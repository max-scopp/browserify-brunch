const browserify = require('browserify');
const watchify = require('watchify');
const mkdirp = require('mkdirp');
const sysPath = require('path');
const { openSync, writeSync, closeSync } = require('fs');
const uglify = require('uglify-js');
const _ = require('lodash');
const loggy = require('loggy');

const cwd = process.cwd();

class BrowserifyInstance {
  constructor(params) {
    this.data = params;
    let options = {
      debug: !this.data.main.production
    }

    _.forEach(this.data.entries, (entry) => loggy.info('\t' + entry))

    options = _.assign(options, watchify.args, this.data.instanceOptions, { entries: _.map(this.data.entries, (v) => sysPath.resolve(cwd, v)) })

    this.__w = browserify(sysPath.resolve(cwd, this.data.entry), options)

    // enable watcher, if dev
    if (this.data.main.watching) {
      this.__w = watchify(this.__w)
    }

    _.forEach(this.data.transforms, (transformer) => {
      this.__w.transform(transformer)
    })

    if (this.data.onBrowserifyLoad instanceof Function) {
      this.data.onBrowserifyLoad.apply(this, [this.__w])
    }

    if (this.data.main.watching) {
      this.__w.on('update', this.handleUpdate)
      this.handleUpdate()
    }
  }

  handleUpdate (fileContents, filePath, cb) {
    this.running = true;
    this.__w.bundle((function (err, js) {
      if (err || !js) {
        loggy.error("Browserify Error", err)

        if (cb instanceof Function) {
          cb(err || true, fileContents, filePath)
        }

        // throwing can hurt people
        // throw err

        // but doing nothing is also bad
        return
      }

      // Browserify > 5.0.0 gives us a buffer object, must convert it to string.
      js = js.toString()

      // Since the files run through browserify are not defined in
      // `brunchConfig.files.javascripts`, they are not picked up by the
      // installed optimizers.
      if (this.data.main.production) {
        let minified = uglify.minify(js, { output: { comments: /(?:^!|@(?:license|preserve|cc_on))/ }, fromString: true })
        js = minified.code
      }

      // Likewise, we don't get folders generated by Brunch.
      let outFile = `${this.data.main.publicPath}/${this.data.compiledPath}`
      mkdirp.sync(sysPath.dirname(outFile))

      let fd = openSync(outFile, 'w+')
      writeSync(fd, js)
      closeSync(fd)

      loggy.info("Compiled " + outFile)

      this.running = false;

      if (this.data.onAfterBundle instanceof Function) {
        this.data.onAfterBundle.apply(this, arguments)
      }

      if (cb instanceof Function) {
        cb(err, js, filePath)
      }
    }).bind(this))
  }
}

module.exports = { BrowserifyInstance };
